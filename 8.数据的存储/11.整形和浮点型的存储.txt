#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int main()
{
	int n = 9;
	//n:00000000 00000000 00000000 00001001
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);//9
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
	//上面那个二进制序列以浮点数角度看的：0(S) 00000000(E) 00000000000000000001001(M)//即(-1)^0 * 0.00000000000000000001001 * 2^-126（E为全0的情况）
	//这要输出六位小数的float数字就是0.000000

	*pFloat = 9.0;
	//9.0//1001.0//(-1)^0 * 1.001 *2^3//S=0;E=3(3+127=130);M=0.001
	//0(S)10000010(E)00100000000000000000000(M)
	//01000001000100000000000000000000
	printf("num的值为：%d\n", n);//1091567616
	//将上面的那串二进制序列换算成十进制即是1091567616
	printf("*pFloat的值为：%f\n", *pFloat);//9.000000
	return 0;
}

/*输出：
n的值为：9
*pFloat的值为：0.000000
num的值为：1091567616
*pFloat的值为：9.000000
*/

//num 和* pF1oat 在内存中明明是同一个数, 为什么浮点数和整数的解读结果会差别这么大 ? 要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。
// (-1)^S * M * 2^E
//9.0 -> 1001.0 -> (-1)^0 * 1.001 * 2^3 //S=0;M=1.001;E=3