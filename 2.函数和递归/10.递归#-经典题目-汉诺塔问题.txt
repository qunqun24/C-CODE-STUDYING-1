/*相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。
游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。
操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。*/ 

/*分析：对于这样一个问题，任何人都不可能直接写出移动盘子的每一步，但我们可以利用下面的方法来解决。设移动盘子数为n，为了将这n个盘子从A杆移动到C杆，可以做以下三步：
(1)以C盘为中介，从A杆将1至n-1号盘移至B杆；
(2)将A杆中剩下的第n号盘移至C杆；
(3)以A杆为中介；从B杆将1至n-1号盘移至C杆。 
这样问题解决了，但实际操作中，只有第二步可直接完成，而第一、三步又成为移动的新问题。以上操作的实质是把移动n个盘子的问题转化为移动n-1个盘，那一、三步如何解决？
事实上，上述方法设盘子数为n, n可为任意数，该法同样适用于移动n-1个盘。因此，依据上法，可解决n -1个盘子从A杆移到B杆(第一步)或从B杆移到C杆(第三步)问题。
现在，问题由移动n个盘子的操作转化为移动n-2个盘子的操作。依据该原理，层层递推，即可将原问题转化为解决移动n -2、n -3… … 3、2，直到移动1个盘的操作，而移动一个盘的操作是可以直接完成的。
至此，我们的任务算作是真正完成了。而这种由繁化简，用简单的问题和已知的操作运算来解决复杂问题的方法，就是递归法。在计算机设计语言中，用递归法编写的程序就是递归程序。*/



#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

int Hanoi1(int n)//算出移动次数  枚举、找规律法 - 有n个盘子 会移动 2^n-1次
{
	if (n != 1)
		return 2 * Hanoi1(n-1) + 1;
	else
		return 1;
}

void move(char c1, char c2)//move函数用来打印出轨迹
{
	printf("%c-->%c\n",c1,c2);
}

void Hanoi2(int n, char x, char y, char z)//显示移动路径 x:移动起点 y:移动经过 z:移动目的地 666
{
	if (n == 1)
		move(x, z);
	else
	{
		Hanoi2(n - 1, x, z, y);//第一步：将放在起始柱x上的n-1个盘子（最大的那个留着）,经由目标柱z,移动到中间柱y上
		move(x, z);//第二步：将a柱上的最大的盘移动到z柱上
		Hanoi2(n - 1, y, x, z); //第三步：将剩下n-1个盘子从y柱经由x柱最终放到z上
	}
}


int main()
{
	int n = 0;
	int ret = 0;
	printf("请输入盘子个数：");
	scanf("%d", &n);
	
	Hanoi2(n,'a','b','c');
	printf("注：a为第一根柱子（起始地），b为第二根柱子，c为第三根柱子（目标地）\n");
	
	ret=Hanoi1(n);
	printf("\nHanoi1：移动这%d个盘子需要%d步\n",n,ret);

	return 0;
}

/*示例：
当n=3时Hanoi2函数的执行情况：                                              即
1.Hanoi2(2, a, c, b);  Hanoi2(1, a, b, c);  move(a, c);                 move(a, c); 
                       move(a, b);                                      move(a, b);
                       Hanoi2(1, c, a, b);  move(c, b);                 move(c, b);
2.move(a, c);                                                           move(a, c);
3.Hanoi2(2, b, a, c); Hanoi2(1, b, c, a);   move(b, a);                 move(b, a);
                      move(b, c);                                       move(b, c);
			    Hanoi2(1, a, b, c);   move(a, c);                 move(a, c);

第一步、第三步用递归，不断化繁为简（n-1），直到n=1，显示轨迹			  
*/




//引用：https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/1945186